= kerbal-control
:author: Sean Donnellan, Fynn Donnellan
:toc: right
:data-uri: false
:doctype: article
:icons: font
:pdf-page-size: A4
:source-highlighter: rouge
:title-page:

== About this document

.HTML version
* link:https://donnels.github.io/kerbal-control/README.html[^]

.PDF version
* link:https://donnels.github.io/kerbal-control/README.pdf[^]

.Github source
* link:https://github.com/donnels/kerbal-control[^]


== Starting point
A project to add some more control to the PS5 Kerbal simulation.

.Screenshot from www.kerbalspaceprogram.com
image::./images/Kerbal.png[]

* link:https://www.kerbalspaceprogram.com/[^]

After installing Kerbal on the PS5 and playing it for a while it quickly became clear that the controllers alone are not enough to enjoy the game.
The search began to find some way of improving things.
Kerbal allows control vi the PS5 controllers AND via keyboard and mouse.
This means it should be possible to add some easy toggles/switches/rotary encoders to pass information to the game.
The first switch would be the space bar which kerbal uses to trigger stages.

=== kerbal key bindings
The following is a list of key bindings we can work with.

.Key bindings for Kerbal
* link:https://wiki.kerbalspaceprogram.com/wiki/Key_bindings[^]

=== Arduino - pro micro (5V)
Initial choice for a prototype is the AVR ATmega32u4 8-bit microcontroller which has a USB controller and can therefore be used as both a keyboard and mouse if required.

"The Pro Micro is an Arduino-compatible microcontroller board developed under an open hardware license by Sparkfun. Clones of the Pro Micro are often used as a lower-cost alternative to a Teensy 2.0 as a basis for a DIY keyboard controller/converter when a lower number of pins would suffice."
-- https://deskthority.net/wiki/Arduino_Pro_Micro

=== WS2812 LEDs
Because it's always good to have status LEDs an the WS2812 is one that is both easy to get and has good libraries with fastled and adafruit.

.Fastled
* link:https://github.com/FastLED/FastLED[^]
* link:https://fastled.io/[^]

The fastled library looks like a good choice although it doesn't (yet) support RGBW LEDs for which I have a LED ring.
The other LED rings I have are less tightly packed with LEDs.
As I have a few WS2812 strips on top of the one RGBW ring the choice went towards the WS2812 to be able to mix the strip and ring.
RGBW is better suited to lighting anyway so let's use it for that later.

== Step 1 - First prototype
To get started I went to an example for LEDs to be able to later set a LED with a key/button.

.First LED example (arduino IDE)
[source%linenums, c++]
----
include::./fastled-test/fastled-test.ino[]
----

The first test looks good.

.Initial breadboard prototype with WS2812 ring and strip
image::./images/Prototype-led-ring-and-strip.jpeg[]

The above code runs a LED around the ring and sets static colours on the strip.
A good start.

== Step 2 - Attach a button to trigger a stage

Since this will be starting rockets let's make it feel that way.
Just the space bar and maybe a toggle to arm it.

.Arduino reference
* keyboard
** link:https://www.arduino.cc/reference/en/language/functions/usb/keyboard/[^]
* Button
** link:https://www.arduino.cc/en/Tutorial/BuiltInExamples/Button[^]
* State change detection
** link:https://www.arduino.cc/en/Tutorial/BuiltInExamples/StateChangeDetection[^]

.Resistor for pull down
image::./images/resistor-10kohm.png[]
We will need to pull down the pin for the button so the above resistor is included to show an example 10K Ohm resistor.

.first buttons
image::./images/Button-Triger-stage.jpeg[]

The big red button is to trigger a stage and the toggle switch is to arm it.

.Very draft UI design
image::./images/kerbal_ctrl_box_prototype.svg[]

Let's see if that works.

.initial tests
[source%linenums, c++]
----
include::./button-test/button-test.ino[]
----

.Why all the fuss about bounce?
* link:https://en.wikipedia.org/wiki/Switch[^]

.Example of bounce from the wikipedia
image::./images/bounce.png

The above code sort of works as a debounced latching button.
The aim though is to read a debounced button and to read it's state changes.

.activity diagram to show the flow
image::./images/debounce.png[]

* ONLY when the button is pressed
** output state ONCE
* When button is released
** Output state once


.Second button test non latching (armed/disarmed)
[source%linenums, c++]
----
include::./button-test2/button-test2.ino[]
----

== Step 3 - bring things together to see how the loop runs with buttons

[WARNING]
====
Work in Progress
====

.Second test with LED ring and leds plus 1 button
[source%linenums, c++]
----
include::./fastled-test2/fastled-test2.ino[]
----


.Example interrupt driven routine debounced
[source%linenums, c++]
----
void my_interrupt_handler()
{
  static unsigned long last_interrupt_time = 0;
  unsigned long interrupt_time = millis();
  // If interrupts come faster than 200ms, assume it's a bounce and ignore
  if (interrupt_time - last_interrupt_time > 200)
  {
    ... do your thing
  }
  last_interrupt_time = interrupt_time;
}
----

The above short section shows a debounced interrupt that uses millis instead of delays.
The important thing here is that if we debounce with delays we stall the whole loop so that if we have a LED animation or something else running it get's stalled. using millis allows the rest to keep running.


== Step 4 - rotary encoders

.An initial example with interrupts
* link:https://gist.github.com/dkgrieshammer/66cce6ec92a6427c16804df84c22cc83[^]


[appendix]
== Requirements

.Initial list of requirements
* Control Kerbal on PS5
** Via USB(A) keyboard interface
*** Use big red button with latch for stages
** Must show actions/button presses
*** WS2812 for key status changes red/green/etc
** Add some safety toggles (arm/disarm)
*** A classic toggle with red cover
** Control 
*** Stage trigger (space bar)
*** SAS (on/off) (t)
*** gear (up/down) (g)
*** time warp (rotary +/-) (.,)
*** throttle (rotary +/-) (shift,cntrl)
*** motors (on/off) (x,k)
*** View (inside/outside) ???

This should cover the most required buttons and should be possible without multiplexing.

[appendix]
== Interface design thoughts
Since the first button is a big red one with a latch it make sense to also show what state it's in.
Adding a LED ring around it sounds like a good idea.
Adding a LED ring around a rotary encoder also sounds like a good idea (optional).

=== Arm/disarm toggle
toggle disarmed:: Arm led LED green(?), latch ring red blink(?)
toggle armed:: ARM led red, latch ring green

=== Triger stage button
unlatched:: ring green
press:: ring red for 1 sec
latched:: Ring orange

[appendix]
== 3d printed test stand
The Aim here is to have a stand to mount the buttons and LEDs to while testing.
After testing this can be used as a template for drilling.
Also this can later be adapted to make a holder for the led ring and potentially the leds that can be mounted under the lid of the box.

.OpenScad source
[source%linenums,openscad]
----
include::./3d/protoTypeStand.scad[]
----

.3d stand STL (second iteration)
image::./3d/Screenshot 2022-02-07 at 20.28.38.png[]

The first test fitting worked well to show up some room for improvement:

* Toggle switch moved left and down
* legs longer
* LED ring proper Radius
